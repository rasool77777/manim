import os
import re
import sys
import shutil
import logging
import tempfile
import asyncio
import json
from pathlib import Path
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes, CallbackQueryHandler
import shutil
import pytz
from datetime import datetime
import re

# Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù€ logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

class ManimBot:
    def __init__(self, token, admin_id):
        self.token = token
        self.admin_id = admin_id
        self.timezone = pytz.timezone('Asia/Baghdad')  # ØªÙˆÙ‚ÙŠØª Ø¨ØºØ¯Ø§Ø¯
        
        # Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø¬ÙˆØ¯Ø© Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ©
        self.user_quality = {}  # Ù‚Ø§Ù…ÙˆØ³ Ù„ØªØ®Ø²ÙŠÙ† Ø¬ÙˆØ¯Ø© ÙƒÙ„ Ù…Ø³ØªØ®Ø¯Ù…
        self.default_quality = "m"  # Ø§Ù„Ø¬ÙˆØ¯Ø© Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ© (Ù…ØªÙˆØ³Ø·Ø©)
        
        # ØªØ®Ø²ÙŠÙ† Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ù…Ø¤Ù‚Øª Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†
        self.pending_code = {}  # Ù‚Ø§Ù…ÙˆØ³ Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ù…Ø¤Ù‚Øª Ù„ÙƒÙ„ Ù…Ø³ØªØ®Ø¯Ù…
        
        # Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù„ØºØ§Øª
        self.user_language = {}  # Ù‚Ø§Ù…ÙˆØ³ Ù„ØªØ®Ø²ÙŠÙ† Ù„ØºØ© ÙƒÙ„ Ù…Ø³ØªØ®Ø¯Ù…
        self.default_language = "ar"  # Ø§Ù„Ù„ØºØ© Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ© (Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©)
        
        # Ù‚Ø§Ù…ÙˆØ³ Ø§Ù„ØªØ±Ø¬Ù…Ø§Øª
        self.translations = {
            'ar': {  # Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©
                'welcome': "ğŸ‘‹ Ù…Ø±Ø­Ø¨Ù‹Ø§ Ø¨Ùƒ ÙÙŠ Ø¨ÙˆØª Manim!\n\nÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø±Ø³Ø§Ù„ ÙƒÙˆØ¯ Manim ÙˆØ³Ø£Ù‚ÙˆÙ… Ø¨Ø¥Ù†Ø´Ø§Ø¡ ÙÙŠØ¯ÙŠÙˆ Ù„Ù‡.\n\nØ§Ø³ØªØ®Ø¯Ù… /help Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©.\n\nÙŠÙ…ÙƒÙ†Ùƒ ØªØºÙŠÙŠØ± Ø§Ù„Ù„ØºØ© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… /language",
                'help': "ğŸ¤– **Manim Bot Help**\n\n**Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ù…ØªØ§Ø­Ø©:**\n- `/start` - Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØªØ±Ø­ÙŠØ¨\n- `/help` - Ø¹Ø±Ø¶ Ù‡Ø°Ù‡ Ø§Ù„Ø±Ø³Ø§Ù„Ø©\n- `/quality` - ØªØºÙŠÙŠØ± Ø¬ÙˆØ¯Ø© Ø§Ù„ÙÙŠØ¯ÙŠÙˆ (l: Ù…Ù†Ø®ÙØ¶Ø©ØŒ m: Ù…ØªÙˆØ³Ø·Ø©ØŒ h: Ø¹Ø§Ù„ÙŠØ©ØŒ k: 4K)\n- `/language` - ØªØºÙŠÙŠØ± Ù„ØºØ© Ø§Ù„Ø¨ÙˆØª\n\n**ÙƒÙŠÙÙŠØ© Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…:**\n1. Ø£Ø±Ø³Ù„ ÙƒÙˆØ¯ Manim Ù…Ø¨Ø§Ø´Ø±Ø© (Ø¨Ø¯ÙˆÙ† Ø£ÙˆØ§Ù…Ø±)\n2. ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø§Ù„ÙƒÙˆØ¯ ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ class ÙŠØ±Ø« Ù…Ù† Scene\n3. Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø¯Ø§Ù„Ø© construct() Ù„Ø¨Ù†Ø§Ø¡ Ø§Ù„Ø±Ø³ÙˆÙ… Ø§Ù„Ù…ØªØ­Ø±ÙƒØ©\n\n**Ù…ØªØ·Ù„Ø¨Ø§Øª Ø§Ù„ÙƒÙˆØ¯:**\n- ÙŠØ¬Ø¨ Ø£Ù† ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ import Ù„Ù„Ù€ manim\n- ÙŠØ¬Ø¨ Ø£Ù† ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ class ÙŠØ±Ø« Ù…Ù† Scene\n- ÙŠØ¬Ø¨ Ø£Ù† ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø¯Ø§Ù„Ø© construct()\n\n**Ù…Ø«Ø§Ù„ ØµØ­ÙŠØ­:**\n```python\nfrom manim import *\n\nclass MyScene(Scene):\n    def construct(self):\n        circle = Circle()\n        self.play(Create(circle))\n        self.wait()\n```\n\n**Ù…Ø«Ø§Ù„ Ù„Ø¥Ù†Ø´Ø§Ø¡ ØµÙˆØ±Ø© Ø«Ø§Ø¨ØªØ©:**\n```python\nfrom manim import *\n\nclass StaticImage(Scene):\n    def construct(self):\n        circle = Circle()\n        circle.set_fill(BLUE, opacity=0.5)\n        self.add(circle)\n```\n\nâš ï¸ **Ù…Ù„Ø§Ø­Ø¸Ø©:** ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Manim Ù…Ø«Ø¨Øª Ø¹Ù„Ù‰ Ø§Ù„Ù†Ø¸Ø§Ù… Ù…Ø¹ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…ØªØ·Ù„Ø¨Ø§Øª.",
                'stats': "ğŸ“Š **Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø¨ÙˆØª**\n\nğŸ†” **Admin ID:** {admin_id}\nğŸ¤– **Ø§Ù„Ø¨ÙˆØª ÙŠØ¹Ù…Ù„ Ø¨Ø´ÙƒÙ„ Ø·Ø¨ÙŠØ¹ÙŠ**\nğŸ“ **Ø¯Ù„ÙŠÙ„ Ø§Ù„Ø¹Ù…Ù„:** {cwd}\nğŸ”§ **Python Version:** {python_version}\nğŸ• **Ø§Ù„ØªÙˆÙ‚ÙŠØª Ø§Ù„Ø­Ø§Ù„ÙŠ:** {current_time}\n\nâœ… **Ø§Ù„Ø­Ø§Ù„Ø©:** Ù†Ø´Ø·",
                'admin_only': "âŒ Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± Ù…ØªØ§Ø­ Ù„Ù„Ù…Ø´Ø±Ù ÙÙ‚Ø·",
                'processing_code': "ğŸ”„ Ø¬Ø§Ø±ÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ÙƒÙˆØ¯...",
                'file_type_error': "âŒ ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ù…Ù„Ù Ø¨Ø§Ù…ØªØ¯Ø§Ø¯ .py Ø£Ùˆ .txt ÙÙ‚Ø·",
                'processing_file': "ğŸ”„ Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ù„Ù ÙˆÙ…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ÙƒÙˆØ¯...",
                'file_error': "âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù…Ù„Ù: {error}",
                'quality_current': "ğŸ¬ **Ø§Ù„Ø¬ÙˆØ¯Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©:** {quality}\n\nÙ„ØªØºÙŠÙŠØ± Ø§Ù„Ø¬ÙˆØ¯Ø©ØŒ Ø§Ø³ØªØ®Ø¯Ù…:\n`/quality l` - Ø¬ÙˆØ¯Ø© Ù…Ù†Ø®ÙØ¶Ø© (Ø£Ø³Ø±Ø¹)\n`/quality m` - Ø¬ÙˆØ¯Ø© Ù…ØªÙˆØ³Ø·Ø© (Ø§ÙØªØ±Ø§Ø¶ÙŠ)\n`/quality h` - Ø¬ÙˆØ¯Ø© Ø¹Ø§Ù„ÙŠØ©\n`/quality k` - Ø¬ÙˆØ¯Ø© 4K (Ø£Ø¨Ø·Ø£)",
                'quality_invalid': "âŒ Ø¬ÙˆØ¯Ø© ØºÙŠØ± ØµØ§Ù„Ø­Ø©. Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª Ø§Ù„Ù…ØªØ§Ø­Ø©:\n`l` - Ù…Ù†Ø®ÙØ¶Ø©\n`m` - Ù…ØªÙˆØ³Ø·Ø©\n`h` - Ø¹Ø§Ù„ÙŠØ©\n`k` - 4K",
                'quality_changed': "âœ… ØªÙ… ØªØºÙŠÙŠØ± Ø§Ù„Ø¬ÙˆØ¯Ø© Ø¥Ù„Ù‰: {quality}",
                'code_invalid': "âŒ Ø§Ù„ÙƒÙˆØ¯ ØºÙŠØ± ØµØ­ÙŠØ­. ØªØ£ÙƒØ¯ Ù…Ù† ÙˆØ¬ÙˆØ¯ class ÙŠØ±Ø« Ù…Ù† Scene ÙˆØ¯Ø§Ù„Ø© construct()",
                'class_not_found': "âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ class ØµØ­ÙŠØ­ ÙÙŠ Ø§Ù„ÙƒÙˆØ¯",
                'code_verified': "âœ… ØªÙ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ÙƒÙˆØ¯ Ø¨Ù†Ø¬Ø§Ø­!\n\nClass: {class_name}\n\nğŸ¬ Ø§Ø®ØªØ± Ø¬ÙˆØ¯Ø© Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©:",
                'processing_error': "âŒ Ø­Ø¯Ø« Ø®Ø·Ø£: {error}",
                'creating_video': "ğŸ¬ Ø¬Ø§Ø±ÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø¨Ø¬ÙˆØ¯Ø© {quality}...",
                'creating_image': "ğŸ–¼ï¸ Ø¬Ø§Ø±ÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØµÙˆØ±Ø© Ø¨Ø¬ÙˆØ¯Ø© {quality}...",
                'request_expired': "âŒ Ø§Ù†ØªÙ‡Øª ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ø·Ù„Ø¨. ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ÙƒÙˆØ¯ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.",
                'sending_video': "ğŸ“¤ Ø¬Ø§Ø±ÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ...",
                'sending_image': "ğŸ“¤ Ø¬Ø§Ø±ÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØ±Ø©...",
                'video_success': "âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø¨Ù†Ø¬Ø§Ø­!\n\nClass: {class_name}\nØ§Ù„Ø¬ÙˆØ¯Ø©: {quality}",
                'image_success': "âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØµÙˆØ±Ø© Ø¨Ù†Ø¬Ø§Ø­!\n\nClass: {class_name}\nØ§Ù„Ø¬ÙˆØ¯Ø©: {quality}",
                'video_fail': "âŒ ÙØ´Ù„ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ:\n```\n{error}\n```",
                'quality_low': "Ù…Ù†Ø®ÙØ¶Ø© (Low)",
                'quality_medium': "Ù…ØªÙˆØ³Ø·Ø© (Medium)",
                'quality_high': "Ø¹Ø§Ù„ÙŠØ© (High)",
                'quality_4k': "4K",
                'language_selection': "ğŸŒ Ø§Ø®ØªØ± Ù„ØºØ© Ø§Ù„Ø¨ÙˆØª:\n\nØ§Ù„Ù„ØºØ© Ø§Ù„Ø­Ø§Ù„ÙŠØ©: {current_language}",
                'language_changed': "âœ… ØªÙ… ØªØºÙŠÙŠØ± Ù„ØºØ© Ø§Ù„Ø¨ÙˆØª Ø¥Ù„Ù‰: {language}",
                'btn_quality_low': "Ù…Ù†Ø®ÙØ¶Ø© (Low)",
                'btn_quality_medium': "Ù…ØªÙˆØ³Ø·Ø© (Medium)",
                'btn_quality_high': "Ø¹Ø§Ù„ÙŠØ© (High)",
                'btn_quality_4k': "4K",
                'btn_language_ar': "ğŸ‡®ğŸ‡¶ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©",
                'btn_language_en': "ğŸ‡¬ğŸ‡§ English",
                'output_type_selection': "ğŸ¬ Ø§Ø®ØªØ± Ù†ÙˆØ¹ Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬:",
                'btn_output_video': "ğŸ¬ ÙÙŠØ¯ÙŠÙˆ",
                'btn_output_image': "ğŸ–¼ï¸ ØµÙˆØ±Ø©",
                'force_video': "âœ… ØªÙ… Ø§Ø®ØªÙŠØ§Ø± Ø¥Ù†Ø´Ø§Ø¡ ÙÙŠØ¯ÙŠÙˆ",
                'force_image': "âœ… ØªÙ… Ø§Ø®ØªÙŠØ§Ø± Ø¥Ù†Ø´Ø§Ø¡ ØµÙˆØ±Ø©"
            },
            'en': {  # Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©
                'welcome': "ğŸ‘‹ Welcome to Manim Bot!\n\nYou can send Manim code and I'll create a video for it.\n\nUse /help to get assistance.\n\nYou can change the language using /language",
                'help': "ğŸ¤– **Manim Bot Help**\n\n**Available Commands:**\n- `/start` - Start the bot\n- `/help` - Show this help\n- `/quality` - Change video quality (l: low, m: medium, h: high, k: 4K)\n- `/language` - Change bot language\n\n**How to Use:**\n1. Send Manim code directly (without commands)\n2. Make sure the code contains a class that inherits from Scene\n3. Use the construct() function to build animations\n\n**Code Requirements:**\n- Must include import for manim\n- Must contain a class that inherits from Scene\n- Must have a construct() function\n\n**Correct Example:**\n```python\nfrom manim import *\n\nclass MyScene(Scene):\n    def construct(self):\n        circle = Circle()\n        self.play(Create(circle))\n        self.wait()\n```\n\n**Example for creating a static image:**\n```python\nfrom manim import *\n\nclass StaticImage(Scene):\n    def construct(self):\n        circle = Circle()\n        circle.set_fill(BLUE, opacity=0.5)\n        self.add(circle)\n```\n\nâš ï¸ **Note:** Make sure Manim is installed on the system with all requirements.",
                'stats': "ğŸ“Š **Bot Statistics**\n\nğŸ†” **Admin ID:** {admin_id}\nğŸ¤– **Bot is running normally**\nğŸ“ **Working Directory:** {cwd}\nğŸ”§ **Python Version:** {python_version}\nğŸ• **Current Time:** {current_time}\n\nâœ… **Status:** Active",
                'admin_only': "âŒ This command is only available to the administrator",
                'processing_code': "ğŸ”„ Processing code...",
                'file_type_error': "âŒ Please send only .py or .txt files",
                'processing_file': "ğŸ”„ Downloading file and processing code...",
                'file_error': "âŒ Error processing file: {error}",
                'quality_current': "ğŸ¬ **Current Quality:** {quality}\n\nTo change quality, use:\n`/quality l` - Low quality (faster)\n`/quality m` - Medium quality (default)\n`/quality h` - High quality\n`/quality k` - 4K quality (slower)",
                'quality_invalid': "âŒ Invalid quality. Available options:\n`l` - Low\n`m` - Medium\n`h` - High\n`k` - 4K",
                'quality_changed': "âœ… Quality changed to: {quality}",
                'code_invalid': "âŒ Invalid code. Make sure there's a class inheriting from Scene and a construct() function",
                'class_not_found': "âŒ No valid class found in the code",
                'code_verified': "âœ… Code verified successfully!\n\nClass: {class_name}\n\nğŸ¬ Choose the desired video quality:",
                'processing_error': "âŒ An error occurred: {error}",
                'creating_video': "ğŸ¬ Creating video with {quality} quality...",
                'creating_image': "ğŸ–¼ï¸ Creating image with {quality} quality...",
                'request_expired': "âŒ Request expired. Please send the code again.",
                'sending_video': "ğŸ“¤ Sending video...",
                'sending_image': "ğŸ“¤ Sending image...",
                'video_success': "âœ… Video created successfully!\n\nClass: {class_name}\nQuality: {quality}",
                'image_success': "âœ… Image created successfully!\n\nClass: {class_name}\nQuality: {quality}",
                'video_fail': "âŒ Failed to create video:\n```\n{error}\n```",
                'quality_low': "Low",
                'quality_medium': "Medium",
                'quality_high': "High",
                'quality_4k': "4K",
                'language_selection': "ğŸŒ Choose bot language:\n\nCurrent language: {current_language}",
                'language_changed': "âœ… Bot language changed to: {language}",
                'btn_quality_low': "Low",
                'btn_quality_medium': "Medium",
                'btn_quality_high': "High",
                'btn_quality_4k': "4K",
                'btn_language_ar': "ğŸ‡®ğŸ‡¶ Arabic",
                'btn_language_en': "ğŸ‡¬ğŸ‡§ English"
            }
        }
        
        # Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ù…Ø¹ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ù…Ø­Ø³Ù†Ø©
        self.app = (
            Application.builder()
            .token(token)
            .build()
        )
        self.setup_handlers()
    
    def setup_handlers(self):
        """Ø¥Ø¹Ø¯Ø§Ø¯ Ù…Ø¹Ø§Ù„Ø¬Ø§Øª Ø§Ù„Ø£ÙˆØ§Ù…Ø± ÙˆØ§Ù„Ø±Ø³Ø§Ø¦Ù„"""
        self.app.add_handler(CommandHandler("start", self.start))
        self.app.add_handler(CommandHandler("help", self.help_command))
        self.app.add_handler(CommandHandler("stats", self.stats_command))
        self.app.add_handler(CommandHandler("quality", self.quality_command))
        self.app.add_handler(CommandHandler("language", self.language_command))
        self.app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, self.handle_code))
        self.app.add_handler(MessageHandler(filters.Document.ALL, self.handle_document))
        self.app.add_handler(CallbackQueryHandler(self.handle_callback_query))
        
    def get_text(self, key, user_id, **kwargs):
        """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù†Øµ Ø§Ù„Ù…ØªØ±Ø¬Ù… Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù„ØºØ© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…"""
        # ØªØ­Ø¯ÙŠØ¯ Ù„ØºØ© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
        lang = self.user_language.get(user_id, self.default_language)
        
        # Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù†Øµ Ù…Ù† Ù‚Ø§Ù…ÙˆØ³ Ø§Ù„ØªØ±Ø¬Ù…Ø§Øª
        text = self.translations.get(lang, {}).get(key, key)
        
        # Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª ÙÙŠ Ø§Ù„Ù†Øµ Ø¥Ø°Ø§ ÙˆØ¬Ø¯Øª
        if kwargs:
            text = text.format(**kwargs)
            
        return text
        
    async def handle_callback_query(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø© Ù„Ù„Ø£Ø²Ø±Ø§Ø±"""
        query = update.callback_query
        await query.answer()
        
        # Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù† callback_data
        data = query.data.split('_')
        
        if len(data) >= 2:
            action = data[0]
            
            if action == "quality":
                await self.handle_quality_selection(update, context)
            elif action == "language":
                await self.handle_language_selection(update, context)
            elif action == "output":
                await self.handle_output_type_selection(update, context)
                
    async def handle_quality_selection(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù„Ù„Ø¬ÙˆØ¯Ø©"""
        query = update.callback_query
        
        # Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ù…Ù† callback_data
        data = query.data.split('_')
        if len(data) < 3 or data[0] != "quality":
            return
        
        quality = data[1]  # l, m, h, k
        user_id = int(data[2])  # Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
        
        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ù…Ø¤Ù‚Øª Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…
        if user_id not in self.pending_code:
            await query.edit_message_text(self.get_text('request_expired', user_id))
            return
        
        # Ø§Ø³ØªØ±Ø¬Ø§Ø¹ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ÙƒÙˆØ¯
        code_info = self.pending_code[user_id]
        code = code_info['code']
        class_name = code_info['class_name']
        force_output_type = code_info.get('force_output_type')
        
        # ØªØ­Ø¯ÙŠØ¯ Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù†Øª ØµÙˆØ±Ø© Ø£Ùˆ ÙÙŠØ¯ÙŠÙˆ
        has_add = code_info.get('has_add', False)
        has_play = code_info.get('has_play', False)
        
        # ØªØ­Ø¯ÙŠØ¯ Ù†ÙˆØ¹ Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ø®ÙŠØ§Ø± Ø§Ù„Ù…ÙØ±ÙˆØ¶ Ø£Ùˆ Ø§Ù„ØªØ­Ù„ÙŠØ² Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ
        is_image = False
        if force_output_type == "image":
            is_image = True
        elif force_output_type == "video":
            is_image = False
        else:
            # Ø§Ù„ØªØ­Ø¯ÙŠØ¯ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ: Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ self.add ÙÙ‚Ø·ØŒ ÙÙ‡Ùˆ ØµÙˆØ±Ø©
            is_image = has_add and not has_play
        
        # Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ø³Ù… Ø§Ù„Ø¬ÙˆØ¯Ø©
        quality_name = self.get_quality_name(quality)
        
        # ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø±Ø³Ø§Ù„Ø©
        if is_image:
            await query.edit_message_text(self.get_text('creating_image', user_id, quality=quality_name))
        else:
            await query.edit_message_text(self.get_text('creating_video', user_id, quality=quality_name))
        
        # ØªÙ†ÙÙŠØ° Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø±Ù†Ø¯Ø±
        try:
            # Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø¬Ù„Ø¯ Ù…Ø¤Ù‚Øª Ù„Ù„Ù…Ø´Ø±ÙˆØ¹
            with tempfile.TemporaryDirectory() as temp_dir:
                temp_path = Path(temp_dir)
                
                # ÙƒØªØ§Ø¨Ø© Ø§Ù„ÙƒÙˆØ¯ ÙÙŠ Ù…Ù„Ù
                code_file = temp_path / f"scene_{user_id}.py"
                with open(code_file, 'w', encoding='utf-8') as f:
                    f.write(code)
                
                # ØªØ´ØºÙŠÙ„ Manim
                success, output_path, error = await self.run_manim(code_file, class_name, temp_path, quality, is_image)
                
                if success and output_path and os.path.exists(output_path):
                    if is_image:
                        # Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØ±Ø©
                        await query.edit_message_text(self.get_text('sending_image', user_id))
                        
                        with open(output_path, 'rb') as image_file:
                            await context.bot.send_photo(
                                chat_id=update.effective_chat.id,
                                photo=image_file,
                                caption=self.get_text('image_success', user_id, class_name=class_name, quality=quality_name)
                            )
                    else:
                        # Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ
                        await query.edit_message_text(self.get_text('sending_video', user_id))
                        
                        with open(output_path, 'rb') as video_file:
                            await context.bot.send_video(
                                chat_id=update.effective_chat.id,
                                video=video_file,
                                caption=self.get_text('video_success', user_id, class_name=class_name, quality=quality_name)
                            )
                    
                    # Ø­Ø°Ù Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©
                    await query.delete_message()
                    
                else:
                    error_msg = self.get_text('video_fail', user_id, error=error)
                    await query.edit_message_text(error_msg[:4000], parse_mode='Markdown')
        
        except Exception as e:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ÙƒÙˆØ¯: {e}")
            await query.edit_message_text(self.get_text('processing_error', user_id, error=str(e)))
        
        # Ø­Ø°Ù Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ù…Ø¤Ù‚Øª Ø¨Ø¹Ø¯ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©
        if user_id in self.pending_code:
            del self.pending_code[user_id]
    
    async def start(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©"""
        user_id = update.effective_user.id
        
        # Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¬Ø¯ÙŠØ¯Ù‹Ø§ØŒ Ù†Ø¹Ø±Ø¶ Ù„Ù‡ Ø®ÙŠØ§Ø±Ø§Øª Ø§Ù„Ù„ØºØ©
        if user_id not in self.user_language:
            # Ø¥Ù†Ø´Ø§Ø¡ Ø£Ø²Ø±Ø§Ø± Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù„ØºØ©
            keyboard = [
                [InlineKeyboardButton("ğŸ‡®ğŸ‡¶ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©", callback_data=f"language_ar_{user_id}")],
                [InlineKeyboardButton("ğŸ‡¬ğŸ‡§ English", callback_data=f"language_en_{user_id}")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            # Ø¹Ø±Ø¶ Ø±Ø³Ø§Ù„Ø© Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù„ØºØ©
            await update.message.reply_text(
                "ğŸŒ Ù…Ø±Ø­Ø¨Ù‹Ø§! Ø§Ø®ØªØ± Ù„ØºØ© Ø§Ù„Ø¨ÙˆØª:\n\nWelcome! Choose bot language:",
                reply_markup=reply_markup
            )
            return
        
        # Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù‚Ø¯ Ø§Ø®ØªØ§Ø± Ù„ØºØ© Ù…Ù† Ù‚Ø¨Ù„ØŒ Ù†Ø¹Ø±Ø¶ Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØªØ±Ø­ÙŠØ¨ Ø¨Ù„ØºØªÙ‡
        welcome_message = self.get_text('welcome', user_id)
        await update.message.reply_text(welcome_message, parse_mode='Markdown')
    
    async def help_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©"""
        user_id = update.effective_user.id
        
        # Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¬Ø¯ÙŠØ¯Ù‹Ø§ØŒ Ù†Ø¹Ø±Ø¶ Ù„Ù‡ Ø®ÙŠØ§Ø±Ø§Øª Ø§Ù„Ù„ØºØ© Ø£ÙˆÙ„Ø§Ù‹
        if user_id not in self.user_language:
            await self.start(update, context)
            return
        
        # Ø¹Ø±Ø¶ Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© Ø¨Ù„ØºØ© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
        help_message = self.get_text('help', user_id)
        await update.message.reply_text(help_message, parse_mode='Markdown')
    
    async def stats_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø¨ÙˆØª (Ù„Ù„Ù…Ø´Ø±Ù ÙÙ‚Ø·)"""
        user_id = update.effective_user.id
        
        # Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¬Ø¯ÙŠØ¯Ù‹Ø§ØŒ Ù†Ø¹Ø±Ø¶ Ù„Ù‡ Ø®ÙŠØ§Ø±Ø§Øª Ø§Ù„Ù„ØºØ© Ø£ÙˆÙ„Ø§Ù‹
        if user_id not in self.user_language:
            await self.start(update, context)
            return
        
        if user_id != self.admin_id:
            await update.message.reply_text(self.get_text('admin_only', user_id))
            return
        
        # Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„ØªÙˆÙ‚ÙŠØª Ø§Ù„Ø­Ø§Ù„ÙŠ
        current_time = datetime.now(self.timezone).strftime("%Y-%m-%d %H:%M:%S")
        
        # Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ù„Ù„ØªØ±Ø¬Ù…Ø©
        stats_vars = {
            'admin_id': self.admin_id,
            'cwd': os.getcwd(),
            'python_version': os.sys.version.split()[0],
            'current_time': current_time
        }
        
        # Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù†Øµ Ø§Ù„Ù…ØªØ±Ø¬Ù…
        stats_message = self.get_text('stats', user_id, **stats_vars)
        
        await update.message.reply_text(stats_message, parse_mode='Markdown')

    async def handle_code(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Ù…Ø¹Ø§Ù„Ø¬Ø© ÙƒÙˆØ¯ Manim Ø§Ù„Ù…Ø±Ø³Ù„ ÙƒÙ†Øµ"""
        user_id = update.effective_user.id
        
        # Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¬Ø¯ÙŠØ¯Ù‹Ø§ØŒ Ù†Ø¹Ø±Ø¶ Ù„Ù‡ Ø®ÙŠØ§Ø±Ø§Øª Ø§Ù„Ù„ØºØ© Ø£ÙˆÙ„Ø§Ù‹
        if user_id not in self.user_language:
            await self.start(update, context)
            return
            
        code = update.message.text
        username = update.effective_user.username or "Unknown"
        
        # ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø·Ù„Ø¨ Ù…Ø¹ Ø§Ù„ØªÙˆÙ‚ÙŠØª
        current_time = datetime.now(self.timezone).strftime("%Y-%m-%d %H:%M:%S")
        logger.info(f"[{current_time}] Ø·Ù„Ø¨ Ø¬Ø¯ÙŠØ¯ Ù…Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… {username} (ID: {user_id})")
        
        # Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© ØªØ£ÙƒÙŠØ¯
        processing_msg = await update.message.reply_text(self.get_text('processing_code', user_id))
        
        # Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø·ÙˆÙŠÙ„ (Ø£ÙƒØ«Ø± Ù…Ù† 4000 Ø­Ø±Ù)
        if len(code) > 4000:
            logger.info(f"Ù…Ø¹Ø§Ù„Ø¬Ø© ÙƒÙˆØ¯ Ø·ÙˆÙŠÙ„ ({len(code)} Ø­Ø±Ù) Ù…Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… {username}")
            # ØªÙ‚Ø³ÙŠÙ… Ø§Ù„ÙƒÙˆØ¯ Ø¥Ù„Ù‰ Ø£Ø¬Ø²Ø§Ø¡ Ù„Ù„ØªØ³Ø¬ÙŠÙ„ ÙÙ‚Ø·
            code_parts = [code[i:i+1000] for i in range(0, len(code), 1000)]
            logger.debug(f"ØªÙ… ØªÙ‚Ø³ÙŠÙ… Ø§Ù„ÙƒÙˆØ¯ Ø¥Ù„Ù‰ {len(code_parts)} Ø¬Ø²Ø¡")
        
        await self.process_code(code, user_id, update, processing_msg)
    
    async def handle_document(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…Ø±ÙÙ‚Ø© (py Ø£Ùˆ txt)"""
        user_id = update.effective_user.id
        
        # Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¬Ø¯ÙŠØ¯Ù‹Ø§ØŒ Ù†Ø¹Ø±Ø¶ Ù„Ù‡ Ø®ÙŠØ§Ø±Ø§Øª Ø§Ù„Ù„ØºØ© Ø£ÙˆÙ„Ø§Ù‹
        if user_id not in self.user_language:
            await self.start(update, context)
            return
            
        username = update.effective_user.username or "Unknown"
        
        # ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø·Ù„Ø¨ Ù…Ø¹ Ø§Ù„ØªÙˆÙ‚ÙŠØª
        current_time = datetime.now(self.timezone).strftime("%Y-%m-%d %H:%M:%S")
        logger.info(f"[{current_time}] Ø·Ù„Ø¨ Ù…Ù„Ù Ù…Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… {username} (ID: {user_id})")
        
        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù†ÙˆØ¹ Ø§Ù„Ù…Ù„Ù
        document = update.message.document
        file_name = document.file_name
        
        if not (file_name.endswith('.py') or file_name.endswith('.txt')):
            await update.message.reply_text(self.get_text('file_type_error', user_id))
            return
        
        # Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© ØªØ£ÙƒÙŠØ¯
        processing_msg = await update.message.reply_text(self.get_text('processing_file', user_id))
        
        try:
            # ØªÙ†Ø²ÙŠÙ„ Ø§Ù„Ù…Ù„Ù
            file = await context.bot.get_file(document.file_id)
            
            with tempfile.TemporaryDirectory() as temp_dir:
                temp_path = Path(temp_dir)
                download_path = temp_path / file_name
                
                await file.download_to_drive(download_path)
                
                # Ù‚Ø±Ø§Ø¡Ø© Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ù…Ù„Ù Ù…Ø¹ Ù…Ø­Ø§ÙˆÙ„Ø© ØªØ±Ù…ÙŠØ²Ø§Øª Ù…Ø®ØªÙ„ÙØ©
                def read_file_with_fallback_encoding(file_path):
                    encodings = ['utf-8', 'latin-1', 'cp1256', 'utf-16']
                    for encoding in encodings:
                        try:
                            with open(file_path, 'r', encoding=encoding) as f:
                                return f.read()
                        except UnicodeDecodeError:
                            continue
                    # Ø¥Ø°Ø§ ÙØ´Ù„Øª Ø¬Ù…ÙŠØ¹ Ø§Ù„ØªØ±Ù…ÙŠØ²Ø§ØªØŒ Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ØªØ±Ù…ÙŠØ² Ø§Ù„Ø«Ù†Ø§Ø¦ÙŠ Ù…Ø¹ Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ø§Ù„Ø£Ø­Ø±Ù ØºÙŠØ± Ø§Ù„ØµØ§Ù„Ø­Ø©
                    with open(file_path, 'r', encoding='utf-8', errors='replace') as f:
                        return f.read()
                
                # Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¯Ø§Ù„Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
                code = read_file_with_fallback_encoding(download_path)
                
                await self.process_code(code, user_id, update, processing_msg)
                
        except Exception as e:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù…Ù„Ù: {e}")
            await processing_msg.edit_text(self.get_text('file_error', user_id, error=str(e)))
    
    async def language_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """ØªØºÙŠÙŠØ± Ù„ØºØ© Ø§Ù„Ø¨ÙˆØª"""
        user_id = update.effective_user.id
        
        # Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¬Ø¯ÙŠØ¯Ù‹Ø§ØŒ Ù†Ø¹Ø±Ø¶ Ù„Ù‡ Ø®ÙŠØ§Ø±Ø§Øª Ø§Ù„Ù„ØºØ© Ø£ÙˆÙ„Ø§Ù‹
        if user_id not in self.user_language:
            await self.start(update, context)
            return
        
        # Ø¹Ø±Ø¶ Ø®ÙŠØ§Ø±Ø§Øª Ø§Ù„Ù„ØºØ©
        current_language = self.user_language.get(user_id, self.default_language)
        current_language_name = "Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©" if current_language == "ar" else "English"
        
        # Ø¥Ù†Ø´Ø§Ø¡ Ø£Ø²Ø±Ø§Ø± Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù„ØºØ©
        keyboard = [
            [InlineKeyboardButton("ğŸ‡®ğŸ‡¶ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©", callback_data=f"language_ar_{user_id}")],
            [InlineKeyboardButton("ğŸ‡¬ğŸ‡§ English", callback_data=f"language_en_{user_id}")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        # Ø¹Ø±Ø¶ Ø±Ø³Ø§Ù„Ø© Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù„ØºØ©
        await update.message.reply_text(
            self.get_text('language_selection', user_id, current_language=current_language_name),
            reply_markup=reply_markup
        )
    
    async def handle_language_selection(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù„Ù„ØºØ©"""
        query = update.callback_query
        
        # Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ù…Ù† callback_data
        data = query.data.split('_')
        if len(data) < 3 or data[0] != "language":
            return
        
        language = data[1]  # ar, en
        user_id = int(data[2])  # Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
        
        # Ø­ÙØ¸ Ø§Ù„Ù„ØºØ© Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…
        self.user_language[user_id] = language
        
        # ØªØ­Ø¯ÙŠØ¯ Ø§Ø³Ù… Ø§Ù„Ù„ØºØ© Ù„Ù„Ø¹Ø±Ø¶
        language_name = "Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©" if language == "ar" else "English"
        
        # Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© ØªØ£ÙƒÙŠØ¯ Ø¨Ù„ØºØ© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
        await query.edit_message_text(
            self.get_text('language_changed', user_id, language=language_name)
        )
        
        # Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØªØ±Ø­ÙŠØ¨ Ø¨Ø¹Ø¯ ØªØºÙŠÙŠØ± Ø§Ù„Ù„ØºØ©
        welcome_message = self.get_text('welcome', user_id)
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text=welcome_message,
            parse_mode='Markdown'
        )
    
    async def quality_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """ØªØºÙŠÙŠØ± Ø¬ÙˆØ¯Ø© Ø§Ù„ÙÙŠØ¯ÙŠÙˆ"""
        user_id = update.effective_user.id
        
        # Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¬Ø¯ÙŠØ¯Ù‹Ø§ØŒ Ù†Ø¹Ø±Ø¶ Ù„Ù‡ Ø®ÙŠØ§Ø±Ø§Øª Ø§Ù„Ù„ØºØ© Ø£ÙˆÙ„Ø§Ù‹
        if user_id not in self.user_language:
            await self.start(update, context)
            return
            
        args = context.args
        
        if not args:
            # Ø¹Ø±Ø¶ Ø§Ù„Ø¬ÙˆØ¯Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©
            current_quality = self.user_quality.get(user_id, self.default_quality)
            quality_name = self.get_quality_name(current_quality)
            
            await update.message.reply_text(
                self.get_text('quality_current', user_id, quality=quality_name),
                parse_mode='Markdown'
            )
            return
        
        # ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¬ÙˆØ¯Ø©
        quality = args[0].lower()
        if quality not in ['l', 'm', 'h', 'k']:
            await update.message.reply_text(
                self.get_text('quality_invalid', user_id),
                parse_mode='Markdown'
            )
            return
        
        # Ø­ÙØ¸ Ø§Ù„Ø¬ÙˆØ¯Ø© Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…
        self.user_quality[user_id] = quality
        quality_name = self.get_quality_name(quality)
        
        await update.message.reply_text(self.get_text('quality_changed', user_id, quality=quality_name))
    
    def get_quality_name(self, quality_code):
        """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ø³Ù… Ø§Ù„Ø¬ÙˆØ¯Ø© Ù…Ù† Ø§Ù„Ø±Ù…Ø²"""
        quality_names = {
            'l': "Ù…Ù†Ø®ÙØ¶Ø© (Low)",
            'm': "Ù…ØªÙˆØ³Ø·Ø© (Medium)",
            'h': "Ø¹Ø§Ù„ÙŠØ© (High)",
            'k': "4K"
        }
        return quality_names.get(quality_code, "Ù…ØªÙˆØ³Ø·Ø© (Medium)")
    
    async def process_code(self, code, user_id, update, processing_msg):
        """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ÙƒÙˆØ¯ Ø³ÙˆØ§Ø¡ ÙƒØ§Ù† Ù†ØµÙ‹Ø§ Ø£Ùˆ Ù…Ù„Ù"""
        try:
            # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„ÙƒÙˆØ¯
            if not self.validate_code(code):
                await processing_msg.edit_text(self.get_text('code_invalid', user_id))
                return
            
            # Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ø³Ù… Ø§Ù„Ù€ class
            class_name = self.extract_class_name(code)
            if not class_name:
                await processing_msg.edit_text(self.get_text('class_not_found', user_id))
                return
            
            # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ self.add Ùˆ self.play Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… regex Ø£ÙƒØ«Ø± Ù‚ÙˆØ©
            add_pattern = re.compile(r'(?<![\w\d_])self\.add\s*\(', re.MULTILINE)
            play_pattern = re.compile(r'(?<![\w\d_])self\.play\s*\(', re.MULTILINE)
            
            # ØªØ­Ø³ÙŠÙ† Ø§ÙƒØªØ´Ø§Ù Ø§Ù„Ø¯ÙˆØ§Ù„ Ø¨Ø§Ù„Ø¨Ø­Ø« ÙÙŠ Ø§Ù„ÙƒÙˆØ¯ Ø¨Ø¹Ø¯ Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ØªØ¹Ù„ÙŠÙ‚Ø§Øª
            def remove_comments(code_str):
                # Ø¥Ø²Ø§Ù„Ø© ØªØ¹Ù„ÙŠÙ‚Ø§Øª Ø§Ù„Ø³Ø·Ø± Ø§Ù„ÙˆØ§Ø­Ø¯
                code_without_comments = re.sub(r'#.*$', '', code_str, flags=re.MULTILINE)
                # Ø¥Ø²Ø§Ù„Ø© ØªØ¹Ù„ÙŠÙ‚Ø§Øª Ù…ØªØ¹Ø¯Ø¯Ø© Ø§Ù„Ø£Ø³Ø·Ø±
                code_without_comments = re.sub(r'"""[\s\S]*?"""', '', code_without_comments)
                code_without_comments = re.sub(r"'''[\s\S]*?'''", '', code_without_comments)
                return code_without_comments
            
            # Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ÙƒÙˆØ¯ Ø¨Ø¹Ø¯ Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ØªØ¹Ù„ÙŠÙ‚Ø§Øª Ù„Ù„Ø¨Ø­Ø«
            code_clean = remove_comments(code)
            has_add = bool(add_pattern.search(code_clean))
            has_play = bool(play_pattern.search(code_clean))
            
            # ØªØ®Ø²ÙŠÙ† Ø§Ù„ÙƒÙˆØ¯ Ù…Ø¤Ù‚ØªÙ‹Ø§ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…
            self.pending_code[user_id] = {
                'code': code,
                'class_name': class_name,
                'message_id': processing_msg.message_id,
                'chat_id': update.effective_chat.id,
                'has_add': has_add,
                'has_play': has_play,
                'force_output_type': None  # Ø¥Ø¶Ø§ÙØ© Ø­Ù‚Ù„ Ø¬Ø¯ÙŠØ¯ Ù„ØªØ®Ø²ÙŠÙ† Ù†ÙˆØ¹ Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬ Ø§Ù„Ù…ÙØ±ÙˆØ¶
            }
            
            # Ø¥Ù†Ø´Ø§Ø¡ Ø£Ø²Ø±Ø§Ø± Ø§Ø®ØªÙŠØ§Ø± Ù†ÙˆØ¹ Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬
            keyboard = [
                [
                    InlineKeyboardButton(self.get_text('btn_output_video', user_id), callback_data=f"output_video_{user_id}"),
                    InlineKeyboardButton(self.get_text('btn_output_image', user_id), callback_data=f"output_image_{user_id}")
                ]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            # Ø¹Ø±Ø¶ Ø®ÙŠØ§Ø±Ø§Øª Ù†ÙˆØ¹ Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…
            await processing_msg.edit_text(
                self.get_text('output_type_selection', user_id),
                reply_markup=reply_markup
            )
            
        except Exception as e:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ÙƒÙˆØ¯: {e}")
            await processing_msg.edit_text(self.get_text('processing_error', user_id, error=str(e)))
    
    def validate_code(self, code):
        """Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© ÙƒÙˆØ¯ Manim"""
        # ØªØ­Ù‚Ù‚ Ø£Ø³Ø§Ø³ÙŠ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„Ø¹Ù†Ø§ØµØ± Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©
        has_import = 'from manim import' in code or 'import manim' in code
        
        # Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† class ÙŠØ±Ø« Ù…Ù† Scene
        class_pattern = re.compile(r'class\s+\w+\s*\([^)]*Scene[^)]*\)')
        has_class = bool(class_pattern.search(code))
        
        # Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø¯Ø§Ù„Ø© construct
        construct_pattern = re.compile(r'def\s+construct\s*\(')
        has_construct = bool(construct_pattern.search(code))
        
        return has_import and has_class and has_construct
    
    def extract_class_name(self, code):
        """Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ø³Ù… Ø§Ù„Ù€ class Ù…Ù† Ø§Ù„ÙƒÙˆØ¯ Ø¨Ø·Ø±ÙŠÙ‚Ø© Ø£ÙƒØ«Ø± Ù‚ÙˆØ©"""
        # Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ØªØ¹Ø¨ÙŠØ± Ø§Ù„Ù†Ù…Ø·ÙŠ Ø§Ù„Ù…Ø­Ø³Ù† Ù„Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø£ÙˆÙ„ class ÙŠØ±Ø« Ù…Ù† Scene
        class_pattern = re.compile(r'class\s+(\w+)\s*\([^)]*(?:Scene|ThreeDScene|MovingCameraScene)[^)]*\)')
        match = class_pattern.search(code)
        
        if match:
            return match.group(1)  # Ø¥Ø±Ø¬Ø§Ø¹ Ø§Ø³Ù… Ø§Ù„Ù€ class
        
        # Ø·Ø±ÙŠÙ‚Ø© Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© ÙÙŠ Ø­Ø§Ù„Ø© ÙØ´Ù„ Ø§Ù„ØªØ¹Ø¨ÙŠØ± Ø§Ù„Ù†Ù…Ø·ÙŠ
        # Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø£ÙŠ class ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø¯Ø§Ù„Ø© construct
        lines = code.split('\n')
        current_class = None
        
        for i, line in enumerate(lines):
            line = line.strip()
            class_match = re.match(r'class\s+(\w+)', line)
            if class_match:
                current_class = class_match.group(1)
            elif current_class and 'def construct' in line:
                return current_class
        
        # Ø¥Ø°Ø§ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø£ÙŠ class Ù…Ù†Ø§Ø³Ø¨ØŒ Ù†Ø¨Ø­Ø« Ø¹Ù† Ø£ÙŠ class
        for line in lines:
            line = line.strip()
            class_match = re.match(r'class\s+(\w+)', line)
            if class_match:
                return class_match.group(1)
        
        return None
    
    async def handle_output_type_selection(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù„Ù†ÙˆØ¹ Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬ (ÙÙŠØ¯ÙŠÙˆ Ø£Ùˆ ØµÙˆØ±Ø©)"""
        query = update.callback_query
        await query.answer()
        
        # Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ù…Ù† callback_data
        data = query.data.split('_')
        if len(data) < 3 or data[0] != "output":
            return
        
        output_type = data[1]  # video Ø£Ùˆ image
        user_id = int(data[2])  # Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
        
        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ù…Ø¤Ù‚Øª Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…
        if user_id not in self.pending_code:
            await query.edit_message_text(self.get_text('request_expired', user_id))
            return
        
        # ØªØ­Ø¯ÙŠØ« Ù†ÙˆØ¹ Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬ Ø§Ù„Ù…ÙØ±ÙˆØ¶
        self.pending_code[user_id]['force_output_type'] = output_type
        
        # Ø¥Ù†Ø´Ø§Ø¡ Ø£Ø²Ø±Ø§Ø± Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ø¬ÙˆØ¯Ø©
        keyboard = [
            [
                InlineKeyboardButton(self.get_text('btn_quality_low', user_id), callback_data=f"quality_l_{user_id}"),
                InlineKeyboardButton(self.get_text('btn_quality_medium', user_id), callback_data=f"quality_m_{user_id}")
            ],
            [
                InlineKeyboardButton(self.get_text('btn_quality_high', user_id), callback_data=f"quality_h_{user_id}"),
                InlineKeyboardButton(self.get_text('btn_quality_4k', user_id), callback_data=f"quality_k_{user_id}")
            ]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        # Ø¹Ø±Ø¶ Ø±Ø³Ø§Ù„Ø© ØªØ£ÙƒÙŠØ¯ Ø§Ø®ØªÙŠØ§Ø± Ù†ÙˆØ¹ Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬ ÙˆØ®ÙŠØ§Ø±Ø§Øª Ø§Ù„Ø¬ÙˆØ¯Ø©
        message_text = self.get_text(f'force_{output_type}', user_id) + "\n\n" + \
                      self.get_text('code_verified', user_id, class_name=self.pending_code[user_id]['class_name'])
        
        await query.edit_message_text(
            message_text,
            reply_markup=reply_markup
        )
    
    async def run_manim(self, code_file, class_name, temp_path, quality, is_image=False, fps="30"):
        """ØªØ´ØºÙŠÙ„ Manim Ù„Ø¥Ù†Ø´Ø§Ø¡ ÙÙŠØ¯ÙŠÙˆ Ø£Ùˆ ØµÙˆØ±Ø©"""
        try:
            # Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø¬Ù„Ø¯Ø§Øª Ù…Ø¤Ù‚ØªØ© Ù„Ù„Ø¹Ù…Ù„
            output_dir = temp_path / "media"
            output_dir.mkdir(exist_ok=True)
            
            # Ø¨Ù†Ø§Ø¡ Ø£Ù…Ø± Manim
            cmd = [
                "manim",
                "render",
                str(code_file),
                class_name,
                "--media_dir", str(output_dir),
                "-q", quality  # Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¬ÙˆØ¯Ø© Ø§Ù„Ù…Ø­Ø¯Ø¯Ø©
            ]
                
            # Ø¥Ø¶Ø§ÙØ© Ø®ÙŠØ§Ø±Ø§Øª Ø¥Ø¶Ø§ÙÙŠØ© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù†ÙˆØ¹ Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬ (ØµÙˆØ±Ø© Ø£Ùˆ ÙÙŠØ¯ÙŠÙˆ)
            if is_image:
                # Ø¥Ø¶Ø§ÙØ© Ø®ÙŠØ§Ø± -s Ù„Ø¥Ù†Ø´Ø§Ø¡ ØµÙˆØ±Ø© Ø«Ø§Ø¨ØªØ©
                cmd.append("-s")
            else:
                # Ø¥Ø¶Ø§ÙØ© Ø®ÙŠØ§Ø±Ø§Øª Ø§Ù„ÙÙŠØ¯ÙŠÙˆ
                cmd.extend(["--format", "mp4", "--fps", fps])
            
            # Ø¥Ø¶Ø§ÙØ© Ø®ÙŠØ§Ø± ØªØ¹Ø·ÙŠÙ„ Ø§Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù…Ø¤Ù‚Øª
            cmd.append("--disable_caching")
            
            # ØªØ´ØºÙŠÙ„ Ø§Ù„Ø£Ù…Ø±
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                cwd=str(temp_path)
            )
            
            stdout, stderr = await process.communicate()
            
            if process.returncode == 0:
                # Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ù…Ù„Ù Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬ (ÙÙŠØ¯ÙŠÙˆ Ø£Ùˆ ØµÙˆØ±Ø©)
                output_path = self.find_output_file(output_dir, is_image)
                return True, output_path, None
            else:
                # Ø§Ø³ØªØ®Ø¯Ø§Ù… errors='replace' Ù„Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ø§Ù„Ø£Ø­Ø±Ù ØºÙŠØ± Ø§Ù„ØµØ§Ù„Ø­Ø© Ø¨Ø¹Ù„Ø§Ù…Ø© Ø§Ø³ØªÙÙ‡Ø§Ù…
                error_msg = stderr.decode('utf-8', errors='replace') if stderr else "Ø®Ø·Ø£ ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ"
                # ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ù†Øµ Ù…Ù† Ø£ÙŠ Ø£Ø­Ø±Ù Ù‚Ø¯ ØªØ³Ø¨Ø¨ Ù…Ø´Ø§ÙƒÙ„ ÙÙŠ Markdown
                error_msg = error_msg.replace('`', '\\`').replace('*', '\\*').replace('_', '\\_')
                # ØªÙ‚ØµÙŠØ± Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø®Ø·Ø£ Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø·ÙˆÙŠÙ„Ø© Ø¬Ø¯Ù‹Ø§ Ù…Ø¹ Ø§Ù„Ø§Ø­ØªÙØ§Ø¸ Ø¨Ø§Ù„Ø£Ø¬Ø²Ø§Ø¡ Ø§Ù„Ù…Ù‡Ù…Ø©
                if len(error_msg) > 3900:
                    # Ø§Ù„Ø§Ø­ØªÙØ§Ø¸ Ø¨Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© ÙˆØ§Ù„Ù†Ù‡Ø§ÙŠØ© Ù…Ù† Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø®Ø·Ø£
                    error_start = error_msg[:1900]
                    error_end = error_msg[-1900:]
                    error_msg = f"{error_start}\n\n... (ØªÙ… Ø§Ø®ØªØµØ§Ø± Ø¬Ø²Ø¡ Ù…Ù† Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø®Ø·Ø£) ...\n\n{error_end}"
                return False, None, error_msg
                    
        except Exception as e:
            return False, None, str(e)
    
    def find_output_file(self, output_dir, is_image=False):
        """Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ù…Ù„Ù Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬ (ÙÙŠØ¯ÙŠÙˆ Ø£Ùˆ ØµÙˆØ±Ø©) ÙÙŠ Ù…Ø¬Ù„Ø¯ Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬"""
        if is_image:
            # Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ù…Ù„ÙØ§Øª Ø§Ù„ØµÙˆØ±
            image_extensions = ['.png', '.jpg', '.jpeg', '.svg']
            
            for root, dirs, files in os.walk(output_dir):
                for file in files:
                    if any(file.lower().endswith(ext) for ext in image_extensions):
                        return os.path.join(root, file)
        else:
            # Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ù…Ù„ÙØ§Øª Ø§Ù„ÙÙŠØ¯ÙŠÙˆ
            video_extensions = ['.mp4', '.mov', '.avi']
            
            for root, dirs, files in os.walk(output_dir):
                for file in files:
                    if any(file.lower().endswith(ext) for ext in video_extensions):
                        return os.path.join(root, file)
        
        return None
        
    def run(self):
        """ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª"""
        print("ğŸ¤– ØªÙ… ØªØ´ØºÙŠÙ„ Manim Bot...")
        self.app.run_polling(drop_pending_updates=True)

def main():
    """Ø§Ù„Ø¯Ø§Ù„Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©"""
    print("Ø¨Ø¯Ø¡ ØªØ´ØºÙŠÙ„ Manim Bot...")
    # Ø¶Ø¹ token Ø§Ù„Ø¨ÙˆØª Ù‡Ù†Ø§
    TOKEN = "7613379698:AAEGFbjKgVrzBPXHPUnFzaXDwGHdAziDZng"
    ADMIN_ID = 7736869278  # ID Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ Ù„Ù„ØªØ­ÙƒÙ… ÙÙŠ Ø§Ù„Ø¨ÙˆØª
    
    if TOKEN == "YOUR_BOT_TOKEN_HERE":
        print("âŒ ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ token Ø§Ù„Ø¨ÙˆØª Ø§Ù„ØµØ­ÙŠØ­")
        print("1. Ø§Ø°Ù‡Ø¨ Ø¥Ù„Ù‰ @BotFather ÙÙŠ ØªÙŠÙ„ÙŠØ¬Ø±Ø§Ù…")
        print("2. Ø£Ù†Ø´Ø¦ Ø¨ÙˆØª Ø¬Ø¯ÙŠØ¯ ÙˆØ§Ø­ØµÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù€ token")
        print("3. Ø§Ø³ØªØ¨Ø¯Ù„ 'YOUR_BOT_TOKEN_HERE' Ø¨Ø§Ù„Ù€ token Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ")
        return
    
    # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Manim
    if not shutil.which("manim"):
        print("âŒ Manim ØºÙŠØ± Ù…Ø«Ø¨Øª Ø¹Ù„Ù‰ Ø§Ù„Ù†Ø¸Ø§Ù…")
        print("Ù‚Ù… Ø¨ØªØ«Ø¨ÙŠØªÙ‡ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù…: pip install manim")
        return
    
    # Ø¥Ù†Ø´Ø§Ø¡ ÙˆØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª
    bot = ManimBot(TOKEN, ADMIN_ID)
    bot.run()

if __name__ == "__main__":
    main()
